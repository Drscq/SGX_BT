# SGX_BT

This project demonstrates **multi-threaded execution** between a **host thread** and an **Intel SGX enclave thread**:
1. **A host thread (`thread_server`)** generates a random integer array.
2. **An enclave thread (`thread_enclave`)** sorts the array inside the enclave.
3. **The host thread sums up the even-indexed elements** of the sorted array.
4. **The enclave directly accesses host memory** using `[user_check]`, avoiding unnecessary copying.

## Table of Contents
- [Prerequisites](#prerequisites)
- [Project Structure](#project-structure)
- [Setup and Installation](#setup-and-installation)
- [Building](#building)
- [Running](#running)
- [Multi-threaded Execution](#multi-threaded-execution)
- [Enclave Memory Configuration](#enclave-memory-configuration)
- [Testing Different Array Sizes](#testing-different-array-sizes)
- [Troubleshooting](#troubleshooting)
- [License](#license)

---

## Prerequisites

1. **Hardware**:  
   - An Intel CPU that supports SGX.  
   - SGX enabled in your BIOS/UEFI.

2. **Software**:  
   - Linux environment with the Intel SGX **driver** installed.  
   - Intel SGX **SDK** and **PSW** (Platform Software) installed. On Ubuntu, for instance:  
     ```bash
     sudo apt-get update
     sudo apt-get install sgx-sdk sgx-psw
     source /opt/intel/sgxsdk/environment
     ```
   - A **C++ compiler** (e.g., `g++`) with support for C++11 or later.  
   - **AESM service** running (`sudo systemctl status aesmd`).

3. **Permissions**:  
   - Make sure you have permissions to run SGX applications (e.g., access to `/dev/sgx*` or `/dev/isgx`).

---

## Project Structure

```
SGX_BT/
├── App
│   ├── App.cpp           # Main host application
│   ├── Enclave_u.h       # Generated by sgx_edger8r (untrusted side)
│   └── Makefile          # Makefile to build the host app
├── Enclave
│   ├── Enclave.cpp       # Trusted enclave code
│   ├── Enclave.edl       # Defines ecall/ocall interfaces
│   ├── Enclave.config.xml# Enclave configuration (heap, stack sizes, etc.)
│   ├── Enclave_t.h       # Generated by sgx_edger8r (trusted side)
│   └── Makefile          # Makefile to build the enclave
├── Makefile              # (Optional) Top-level Makefile
└── README.md             # This file
```

- **Enclave.edl**: Defines `ecall_sort_array`, which allows sorting an array allocated in host memory.  
- **Enclave.cpp**: Implements the sorting logic securely inside SGX.  
- **App.cpp**: Spawns two threads—one to generate an array and another to call the enclave function.

---

## Setup and Installation

1. **Clone or copy** this repository into your local machine:
   ```bash
   git clone https://github.com/your-username/SGX_BT.git
   ```
2. **Enter** the directory:
   ```bash
   cd SGX_BT
   ```
3. **Source** the Intel SGX SDK environment script:
   ```bash
   source /opt/intel/sgxsdk/environment
   ```
   This makes the `sgx_edger8r` and libraries available in your path.

---

## Building

### **Build Everything**
```bash
make clean
make
```
This builds both the enclave (`Enclave.signed.so`) and the host application (`app`).

### **Build Separately**
1. **Build the enclave**:
   ```bash
   cd Enclave
   make clean
   make
   cd ..
   ```
2. **Build the host app**:
   ```bash
   cd App
   make clean
   make
   cd ..
   ```

After building, you should have:
- **`Enclave.signed.so`** (the signed enclave).
- **`app`** (the host application).

---

## Running

Run the application:
```bash
./app
```
Expected output:
```
Host generated array: [23, 8, 15, 42, 7, 3, 56, 21]
Enclave sorted array: [3, 7, 8, 15, 21, 23, 42, 56]
Sum of even-indexed elements: 3 + 8 + 21 + 42 = 74
```

---

## Multi-threaded Execution

- **Host thread (`thread_server`)**:
  - Generates an array with random integers.
  - Calls `ecall_sort_array()` to send the array **directly to the enclave**.

- **Enclave thread (`thread_enclave`)**:
  - Sorts the array **inside SGX**.
  - Uses `[user_check]` to **directly access** the host’s memory **without copying**.

### **EDL Declaration**
```c
enclave {
    trusted {
        public void ecall_sort_array([user_check] int* arr, size_t size);
    };
};
```

### **Memory Validation in Enclave Code**
```cpp
void ecall_sort_array(int* arr, size_t size) {
    if (!sgx_is_outside_enclave(arr, size * sizeof(int))) {
        return;  // Invalid memory, reject access
    }
    std::sort(arr, arr + size);  // Sort in-place
}
```

---

## Enclave Memory Configuration

Increase enclave heap size for larger arrays in **`Enclave.config.xml`**:
```xml
<EnclaveConfiguration>
    <HeapMaxSize>0x2000000</HeapMaxSize> <!-- 32 MB heap -->
</EnclaveConfiguration>
```
Then **rebuild** the enclave.

---

## Testing Different Array Sizes

1. **Modify** `App.cpp`:
   ```cpp
   const size_t array_size = 10 * 1024 * 1024; // 10 million elements
   ```
2. **Rebuild** and run:
   ```bash
   make clean
   make
   ./app
   ```

---

## Troubleshooting

- **SGX_ERROR_INVALID_PARAMETER (Error 4102)**:  
  - Ensure buffer pointers and sizes match the `[user_check]` declaration.
  
- **SGX_ERROR_ENCLAVE_LOST (Error 3)**:  
  - May indicate power transition or insufficient EPC.
  
- **Runtime crash or memory errors**:  
  - Increase `<HeapMaxSize>` in `Enclave.config.xml`.

- **Slow performance for large arrays**:  
  - Try **chunking data** into smaller pieces.

---

## License

This project is based on Intel’s SGX sample code and is distributed under the [Intel Sample Code License](https://software.intel.com/content/www/us/en/develop/articles/intel-sample-source-code-license-agreement.html).
